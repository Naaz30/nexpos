alias processTableEntry R8;
processTableEntry = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 5*CORE + 1]*16);


[processTableEntry + 9] = 9;
[processTableEntry + 13] = SP;



alias userSP R4;
userSP = SP;



SP = [processTableEntry + 11] * 512 - 1;


multipush(R8,R4);
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;
multipop(R8,R4);



alias fileName R1;
fileName = [[PTBR + 2*((userSP - 4)/512)] * 512 + ((userSP - 4)%512)];


alias ret R9;
ret = [PTBR + 2*((userSP - 1)/512)] * 512 + ((userSP - 1)%512);


alias i R7;
alias bool R3;

i = 0;
bool = 0;

while(i < MAX_FILE_NUM) do
     
    if([INODE_TABLE + (i*16) + 1] == fileName && [INODE_TABLE + (i*16)] == EXEC)then

       bool = 1;
       break;

    endif;

    i = i + 1;

endwhile ;




if(bool == 0)then
  
    [ret] = -1;
	[processTableEntry + 9] = 0;

    multipush(R4);
    R1 = RELEASE_LOCK;
    R2 = KERN_LOCK;
    call ACCESS_CONTROL;
    multipop(R4);

	SP = userSP;
	ireturn;

endif;


multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);
R1 = 3;
R2 = [SYSTEM_STATUS_TABLE + 5*CORE + 1];
call MOD_1;.
multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);



[MEMORY_FREE_LIST + [processTableEntry + 11]] = 1;
[SYSTEM_STATUS_TABLE + 2] = [SYSTEM_STATUS_TABLE + 2] - 1;


SP = [processTableEntry + 11] * 512 - 1;
[processTableEntry + 4] = RUNNING;
[processTableEntry + 7] = i;




//Library
[PTBR + 0] = 63;
[PTBR + 1] = "0100";
[PTBR + 2] = 64;
[PTBR + 3] = "0100";



//Heap
[PTBR + 4] = -1;
[PTBR + 5] = "0000";
[PTBR + 6] = -1;
[PTBR + 7] = "0000";




//Stack
multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);
R1 = 1;
call MOD_2;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";
multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);
multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);
R1 = 1;
call MOD_2;
[PTBR + 18] = R0;
[PTBR + 19] = "0110";
multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15);



if([INODE_TABLE + i*16 + 8] != -1)then

   multipush(R1,R2,R3,R4,R5,R6,R7,R8,R9);
   R1 = 5;
   R2 = [INODE_TABLE + i*16 + 8];
   call MOD_2;
   [PTBR+ 8] = R0;
   [PTBR+ 9] = "0100";
   multipop(R1,R2,R3,R4,R5,R6,R7,R8,R9);

else
	[PTBR+ 8] = -1;
	[PTBR+ 9] = "0000";
endif;








alias j R6;
j = 1;
while(j < 4) do
	
	
		
	[PTBR+ 8 + 2*j] = -1;
	[PTBR+ 9 + 2*j] = "0000";
		
	j = j + 1;
endwhile;


alias dmtEntry R12;
dmtEntry = DISK_MAP_TABLE + 10*[SYSTEM_STATUS_TABLE + 5*CORE + 1];


[dmtEntry] = -1;
[dmtEntry + 1] = -1;
[dmtEntry + 2] = -1;
[dmtEntry + 3] = -1;
[dmtEntry + 8] = -1;
[dmtEntry + 9] = -1;


j = 0;
while(j < 4)do

   [dmtEntry + 4 + j] = [INODE_TABLE + (i*16) + 8 + j];
   j = j + 1;

endwhile;


j = 0;
while(j < 16) do
	[(([processTableEntry + 11] + 1)*512 ) - 16 + j] = -1;
	j = j + 1;
endwhile;


[[PTBR + 16] * 512] = [[PTBR+ 8] * 512 + 1];

[processTableEntry + 9] = 0;

multipush(R4);
R1 = RELEASE_LOCK;
R2 = KERN_LOCK;
call ACCESS_CONTROL;
multipop(R4);




SP = 8*512;
ireturn;