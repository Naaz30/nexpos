[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1]*16 ) + 13] = SP;


SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1]*16 ) + 11] * 512 - 1;

backup;


if([SYSTEM_STATUS_TABLE + 5] != 0)then

    if([SYSTEM_STATUS_TABLE + 1] == 15) then
		    R1 = [SYSTEM_STATUS_TABLE + 5];
			R2 = [SYSTEM_STATUS_TABLE + 1];
			call MOD_6;

    endif;



else

    if([SYSTEM_STATUS_TABLE + 2] < MEM_LOW)then
        [SYSTEM_STATUS_TABLE + 5] = SWAP_OUT;

    else
       
        if([SYSTEM_STATUS_TABLE + 4] > 0)then

            alias i R4;
            i = 3;
			while(i < 15) do
				if([PROCESS_TABLE + i*16 + 6] == 1 && [PROCESS_TABLE + i*16 + 4] == READY && [PROCESS_TABLE + i*16] > MAX_TICK) then
					[SYSTEM_STATUS_TABLE + 5] = SWAP_IN;
					break;
				endif;
				i = i + 1;
			endwhile;
			
			if([SYSTEM_STATUS_TABLE + 2] > MEM_HIGH) then
				[SYSTEM_STATUS_TABLE + 5] = SWAP_IN;
			endif;


            

        endif;


    endif;





endif;










[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 4] = READY;


alias i R3;

i = 0;

while(i < MAX_PROC_NUM)do
  
  if([PROCESS_TABLE + 16*i + 4] != TERMINATED )then
      [PROCESS_TABLE + 16*i] = [PROCESS_TABLE + 16*i] + 1;
  endif;

  i = i + 1;
endwhile;







//call_scheduler_module
call MOD_5;

restore;


SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1]*16 )+ 13];
[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE+1]*16 ) + 9] = 0;

ireturn;